p_value <- 2 * (1 - pnorm(abs(z)))
} else if(input$sides=="1-sided (upper)"){
p_value <-  pnorm(z,lower.tail = F)} else{p_value <-  pnorm(z)}
# Define the color based on p-value and alpha
tail_color <- ifelse(p_value < input$alpha, "red", "blue")
# Generate x values for the plot
x_values <- seq(input$xbar - 5*se, input$xbar + 5*se, length.out = 1000)
if(input$sides=="2-sided"){
shade_vals1 = x_values[x_values<=min(input$xbar, 2*input$mu-input$xbar)]
} else if(input$sides=="1-sided (upper)"){
shade_vals1 = NA
} else{shade_vals1 = x_values[x_values<=min(input$xbar, 2*input$mu-input$xbar)]}
if(input$sides=="2-sided"){
shade_vals2 = x_values[ x_values>=max(input$xbar, 2*input$mu-input$xbar)]
} else if(input$sides=="1-sided (upper)"){
shade_vals2 = x_values[x_values>=max(input$xbar, 2*input$mu-input$xbar)]
} else{shade_vals2 = NA}
# Calculate y values for the density function
y_values <- dnorm(x_values, mean = input$mu, sd = se)
1-sided (upper)
input$sides="1-sided (upper)"
z
mu
input$mu
input$xbar
input$mu
input
p_value
pnorm(z)
pnorm(z,lower.tail = F)
pnorm(z,lower.tail = F)
z
phat = 15/15
phat + qnorm(0.975) * sqrt(phat*(1-phat)/15)
phat - qnorm(0.975) * sqrt(phat*(1-phat)/15)
sqrt(phat*(1-phat)/15)
install.packages("shinylive")
library(shinylive)
library(httpuv)
getwd
getwd()
list.files()
shinylive::export(appdir = "ANOVA_shiny_2/", destdir = "docs")
httpuv::runStaticServer("docs/", port = 8008)
?shiny::sliderInput
library(tidyverse)
set.seed(234)
N = 150
x1 = runif(n = N, max = 10) %>% round()
y = 4.2 + 1.5*x1 + rnorm(n = N, sd = 1.3)
origx2<-(3 +rnorm(n = N, sd =.5))
X = cbind(scale(x1),scale(origx2))
c1 = var(X)
chol1 = solve(chol(c1))
newx = X %*% chol1
R2 = matrix(c(1,0.75, 0.75, 1), nrow = 2)
chol2 = chol(R2)
finalx = newx %*% chol2 * sd(x1) + mean(x1)
x2 = finalx[,2]/1.9
vals = list( x2=x2,c=1,av.data=NULL,dt=data.frame(x1, x2 =x2,y),cor = 0.75)
input = list(cor1 = 0.75, c = )
input = list(cor1 = 0.75, c = 1)
cr = as.numeric(input$cor1)
if(!cr%in%c(1,-1)){
R2 = matrix(c(1,cr, cr, 1), nrow = 2)
chol2 = chol(R2)
finalx = newx %*% chol2 * sd(x1) + mean(x1)
x2 = finalx[,2]/1.9
} else {x2 = cr * x1}
vals$x2 = x2
vals$dt = data.frame(x1, x2 = vals$x2,y) %>% mutate(r_x2 = plyr::round_any(vals$x2, .5))
vals$cor = as.numeric(input$cor1)
xres1 = round(lm(x1 ~ x2, data = vals$dt)$residuals,digits = 6)
yres1 = round(lm(y ~ x2, data = vals$dt)$residuals , digits = 6)
xres2 = round(lm(x2 ~ x1, data = vals$dt)$residuals, digits = 6)
yres2 = round(lm(y ~ x1, data = vals$dt)$residuals, digits = 6)
vals$av.data = data.frame(x_axis = c(xres1, xres2),
y_axis = c(yres1, yres2),
variable = rep(c("Removing x2", "Removing x1"),
each = 50))
dt = data.frame(x1,y) %>% mutate(x1c = x1*vals$c)
dt %>%
ggplot(aes(x = x1c, y=y)) +
geom_point() +
theme_bw() +
labs(x = paste0(vals$c," * x")) +
xlim(0, 30) +
geom_smooth(method = "lm", formula = y~x, se = F)
dt = data.frame(x1,y) %>% mutate(x1c = x1*vals$c)
se = (summary(lm(y~x1c, data = dt ))$coef[2,2]) %>%
round(digits=5)
print(paste0("Standard error for slope coefficient (\u03B2): ",se))
dt = data.frame(x1,y) %>% mutate(x1c = x1*vals$c)
se = (summary(lm(y~x1, data = dt ))$coef[2,2]) %>%
round(digits=5)
print(paste0("Standard error for original slope coefficient (\u03B2): ",se))
dt = data.frame(x1,y) %>% mutate(x1c = x1*vals$c)
sd = sd(dt$x1c) %>% round(digits = 5)
print(paste0("Standard deviation of scaled x (",vals$c,"x): ",sd))
sd = sd(x1) %>% round(digits = 5)
print(paste0("Standard deviation of x (original): ",sd))
ggpairs(vals$dt %>% select(-r_x2),
# upper = list(continuous = wrap("blank")),
lower = list(continuous = "points"),
diag = list(continuous = "densityDiag")) +
theme_bw()
library(GGally)
ggpairs(vals$dt %>% select(-r_x2),
# upper = list(continuous = wrap("blank")),
lower = list(continuous = "points"),
diag = list(continuous = "densityDiag")) +
theme_bw()
vals$dt %>%
ggplot(aes(x = x1, y=y, color = x2)) +
geom_point() +
theme_bw() +
xlim(0, 10) +
scale_color_viridis_c(option="turbo") +
labs(title  = "Data colored by x2 value")
vals$dt %>%
ggplot(aes(x = x1, y=y)) +
geom_point(aes(color = x2)) +
theme_bw() +
xlim(0, 10) +
scale_color_viridis_c(option="turbo") +
facet_wrap(.~r_x2)+
labs(title  = "Data split by x2 value") +
geom_smooth(method = "lm", se = F, linewidth = 0.5, aes(color = r_x2)) +
labs(color = "x2")
vals$dt %>%
ggplot(aes(x = x1, y=y)) +
geom_point(aes(color = x2)) +
theme_bw() +
xlim(0, 10) +
scale_color_viridis_c(option="turbo") +
facet_wrap(.~r_x2)+
labs(title  = "Data split by x2 value") +
geom_smooth(method = "lm", se = F, size = 0.5, aes(color = r_x2)) +
labs(color = "x2")+
geom_vline(data = vals$dt %>%  group_by(r_x2) %>% summarize(mean_x = mean(x1)), aes(xintercept = mean_x), linetype = "dashed", color = "black") +
geom_hline(data = vals$dt %>% group_by(r_x2) %>% summarize(mean_y = mean(y)), aes(yintercept = mean_y), linetype = "dashed", color = "black") +
theme(legend.position = "none")
vals$av.data %>%
filter(variable=="Removing x2") %>%
mutate(x2 = vals$x2)%>%
ggplot(aes(x = x_axis, y = y_axis)) +
theme_bw() +
geom_smooth(method = "lm",color = "black", se = F,linewidth = 0.5) +
geom_point(aes(color = x2)) +
# geom_smooth(method = "lm", aes(color = x2, group = x2), linewidth = 0.5, alpha = 0.1, se = F)+
labs(x = "Residuals (x1 | x2)", y = "Residuals (Y | x2)",
title = "Added Variable Plot",
subtitle = "Adjusting for x2") +
scale_color_viridis_c(option="turbo") +
geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
geom_vline(xintercept = 0,linetype = "dashed", color = "black")
vif = round(1/(1-as.numeric(vals$cor)^2),5)
print(paste0("Variance Inflation Factor: ",vif))
dt %>%
ggplot(aes(x = x1c, y=y)) +
geom_point() +
theme_bw() +
labs(x = paste0(vals$c," * x")) +
xlim(0, 30) +
geom_smooth(method = "lm", formula = "y ~ x", se = F)
set.seed(234)
N = 150
x1 = runif(n = N, max = 10) %>% round()
library(tidyverse)
set.seed(234)
N = 150
x1 = runif(n = N, max = 10) %>% round()
y = 4.2 + 1.5*x1 + rnorm(n = N, sd = 1.3)
origx2<-(3 +rnorm(n = N, sd =.5))
X = cbind(scale(x1),scale(origx2))
c1 = var(X)
chol1 = solve(chol(c1))
newx = X %*% chol1
R2 = matrix(c(1,0.75, 0.75, 1), nrow = 2)
chol2 = chol(R2)
finalx = newx %*% chol2 * sd(x1) + mean(x1)
x2 = finalx[,2]/1.9
dt = data.frame(x1,y) %>% mutate(x1c = x1*vals$c)
dt = data.frame(x1,y) %>% mutate(x1c = x1)
dt %>%
ggplot(aes(x = x1c, y=y)) +
geom_point() +
theme_bw() +
labs(x = paste0(vals$c," * x")) +
xlim(0, 30) +
geom_smooth(method = "lm", formula = "y ~ x", se = F)
vals = list(c=1)
dt %>%
ggplot(aes(x = x1c, y=y)) +
geom_point() +
theme_bw() +
labs(x = paste0(vals$c," * x")) +
xlim(0, 30) +
geom_smooth(method = "lm", formula = "y ~ x", se = F)
?geom_smooth
load("unhdd2020.rmph.rData", verbose = T)
library(shiny)
renderText( print(getwd()))
getwd()
data_url <- "https://haleykgrant.github.io/tutorial_data/data/bmd.csv"
data_url
list.files()
colnames(unhdd)
install.packages("shinylive")
x = c(2.5, 3, 3.5, 5)
mean(x)
x = c(2.5, 3, 3.5, 3.5, 5)
mean(x)
qnorm(0.975)^2 * 6.7^2
qnorm(0.975)^2 * 7^2
library(tidyverse)
geom_segment()
mu1 <- 2;  sd1 <- 1
mu2 <- 5;  sd2 <- 1
input$vr = 1
input = list(vr = 1)
mu <- c(mu1, mu2)
sd2 <- sqrt(sd1^2 * input$vr)
sigma <- matrix(c(sd1^2, input$rho * sd1 * sd2,
input$rho * sd1 * sd2, sd2^2), 2, 2)
bulk_draws <- MASS::mvrnorm(n = 100, mu = mu, Sigma = sigma)
bulk_diffs <- bulk_draws[,1] - bulk_draws[,2]
bulk_draws
bulk_diffs
bulk_draws <- MASS::mvrnorm(n = 100000, mu = mu, Sigma = sigma)
mu1
mu2
input$rho = 0
mu <- c(mu1, mu2)
sd2 <- sqrt(sd1^2 * input$vr)
sigma <- matrix(c(sd1^2, input$rho * sd1 * sd2,
input$rho * sd1 * sd2, sd2^2), 2, 2)
bulk_draws <- MASS::mvrnorm(n = 100, mu = mu, Sigma = sigma)
bulk_diffs <- bulk_draws[,1] - bulk_draws[,2]
MASS::mvrnorm(n = 10000, mu = mu, Sigma = sigma)
bulk_draws <-MASS::mvrnorm(n = 10000, mu = mu, Sigma = sigma)
bulk_diffs <- bulk_draws[,1] - bulk_draws[,2]
var(bulk_diffs)
1 + 1
install.packages("shinylive")
install.packages("S7")
# 2. Install/Update shinylive
install.packages("shinylive")
library(tidyverse)
input = list(vr = 1, rho = 0)
mu1 <- 2;  sd1 <- 1
mu2 <- 5;  sd2 <- 1
vals <- list(
draws1 = numeric(),
draws2 = numeric(),
diffs  = numeric()
)
mu <- c(mu1, mu2)
sd2 <- sqrt(sd1^2 * input$vr)
sigma <- matrix(c(sd1^2, input$rho * sd1 * sd2,
input$rho * sd1 * sd2, sd2^2), 2, 2)
new_draw <- MASS::mvrnorm(n = 1, mu = mu, Sigma = sigma)
new_draw
vals$draws1 <- new_draw[1]
vals$draws2 <- new_draw[2]
vals$diffs  <- c(vals$diffs, new_draw[1] - new_draw[2])
sd2 <- sqrt(sd1^2 * input$vr)
# Theoretical SD of the difference given correlation
diff_sd <- sqrt(sd1^2 + sd2^2 - 2 * input$rho * sd1 * sd2)
x_range <- seq(min(mu1 - 4*sd1, mu2 - 4*sd2),
max(mu1 + 4*sd1, mu2 + 4*sd2),
length.out = 600)
# Data for the two theoretical normals
df <- rbind(
data.frame(x = x_range, y = dnorm(x_range, mean = mu1, sd = sd1), dist = "x̄1"),
data.frame(x = x_range, y = dnorm(x_range, mean = mu2, sd = sd2), dist = "x̄2")
)
df.x1 = df %>% filter(dist == "x̄1")
df.x2 = df %>% filter(dist != "x̄1")
p1 <- ggplot(df, aes(x, y, color = dist)) +
geom_line(linewidth = 1.2) +
scale_color_manual(values = c("navy","steelblue1")) +
{
if (length(vals$draws1) > 0) {
list(
geom_segment(aes(
x = vals$draws1,
xend = vals$draws2,
y = 0, yend = 0
), color = "firebrick1", linewidth = 0.75, inherit.aes = FALSE),
geom_point(aes(x = vals$draws1, y = 0), color = "navy", size = 3, inherit.aes = FALSE),
geom_point(aes(x = vals$draws2, y = 0), color = "steelblue1", size = 3, inherit.aes = FALSE),
geom_segment(aes(x = vals$draws1, xend = vals$draws1, yend = df.x1$y[which.min(abs(df.x1$x - vals$draws1))], y = 0), color = "navy") ,
geom_segment(aes(x = vals$draws2, xend = vals$draws2, yend = df.x2$y[which.min(abs(df.x2$x - vals$draws2))], y = 0), color = "steelblue1")
)
}
} +
theme_minimal(base_size = 14) +
labs(x = "Value", y = "Density", color = "Distribution")
p1
vals
n_points <- length(vals$diffs)
binwidth <- 0.2
# Parameters for theoretical difference distribution
mu_diff <- mu1 - mu2
sd_diff <- sqrt(sd1^2 + sd2^2 - 2 * input$rho * sd1 * sd2)
sd_diff0 <- sqrt(sd1^2 + sd2^2 )
# Maximum expected count occurs at the mode (center of normal)
expected_max <- n_points * dnorm(mu_diff, mean = mu_diff, sd = sd_diff) * binwidth
y_max <- ceiling(expected_max) + ceiling(sqrt(n_points))
if(y_max==Inf) {y_max = n_points + ceiling(n_points/50) }
# Histogram
p2 <-  ggplot() +
geom_histogram(aes(x = vals$diffs), binwidth = binwidth, fill = "firebrick1", color = "black") +
coord_cartesian(
xlim = c(mu_diff + -4*sd_diff0 - binwidth, mu_diff + 4*sd_diff0 + binwidth),
ylim = c(0, y_max)  # y-axis expands in steps
) +
theme_minimal(base_size = 14) +
labs(x = "x̄₁ - x̄₂", y = "Count", title =paste0("Correlation: ", cr))
cr = 0
y_max <- ceiling(expected_max) + ceiling(sqrt(n_points))
if(y_max==Inf) {y_max = n_points + ceiling(n_points/50) }
# Histogram
p2 <-  ggplot() +
geom_histogram(aes(x = vals$diffs), binwidth = binwidth, fill = "firebrick1", color = "black") +
coord_cartesian(
xlim = c(mu_diff + -4*sd_diff0 - binwidth, mu_diff + 4*sd_diff0 + binwidth),
ylim = c(0, y_max)  # y-axis expands in steps
) +
theme_minimal(base_size = 14) +
labs(x = "x̄₁ - x̄₂", y = "Count", title =paste0("Correlation: ", cr))
ggplot(data.frame(x1 = vals$draws1, y = vals$draw2)) +
geom_point() +
theme_bw() +
labs(x = "X1", y = "X2")
vals
vals$draws1
vals$draws2
p3 <- ggplot(data.frame(x1 = vals$draws1, y = vals$draws2)) +
geom_point() +
theme_bw() +
labs(x = "X1", y = "X2")
p3
ggplot(data.frame(x1 = vals$draws1, y = vals$draws2)) +
geom_point(aes(x = x1, y = x2)) +
theme_bw() +
labs(x = "X1", y = "X2")
ggplot(data.frame(x1 = vals$draws1, x2 = vals$draws2)) +
geom_point(aes(x = x1, y = x2)) +
theme_bw() +
labs(x = "X1", y = "X2")
p3 <- ggplot(data.frame(x1 = vals$draws1, x2 = vals$draws2)) +
geom_point(aes(x = x1, y = x2)) +
theme_bw() +
labs(x = "X1", y = "X2")
p3
vals
mu <- c(mu1, mu2)
sd2 <- sqrt(sd1^2 * input$vr)
sigma <- matrix(c(sd1^2, input$rho * sd1 * sd2,
input$rho * sd1 * sd2, sd2^2), 2, 2)
new_draw <- MASS::mvrnorm(n = 1, mu = mu, Sigma = sigma)
vals$draws1 <- new_draw[1]
vals$draws2 <- new_draw[2]
vals$diffs  <- c(vals$diffs, new_draw[1] - new_draw[2])
vals
vals$draws1 <- c(vals$draws1, new_draw[1])
vals$draws2 <- c(vals$draws2, new_draw[2])
vals$diffs  <- c(vals$diffs, new_draw[1] - new_draw[2])
new_draw <- MASS::mvrnorm(n = 1, mu = mu, Sigma = sigma)
vals$draws1 <- c(vals$draws1, new_draw[1])
vals$draws2 <- c(vals$draws2, new_draw[2])
vals$diffs  <- c(vals$diffs, new_draw[1] - new_draw[2])
vals
vals$draws1[length(vals$draws1)]
sd2 <- sqrt(sd1^2 * input$vr)
# Theoretical SD of the difference given correlation
diff_sd <- sqrt(sd1^2 + sd2^2 - 2 * input$rho * sd1 * sd2)
x_range <- seq(min(mu1 - 4*sd1, mu2 - 4*sd2),
max(mu1 + 4*sd1, mu2 + 4*sd2),
length.out = 600)
# Data for the two theoretical normals
df <- rbind(
data.frame(x = x_range, y = dnorm(x_range, mean = mu1, sd = sd1), dist = "x̄1"),
data.frame(x = x_range, y = dnorm(x_range, mean = mu2, sd = sd2), dist = "x̄2")
)
df.x1 = df %>% filter(dist == "x̄1")
df.x2 = df %>% filter(dist != "x̄1")
d1 = vals$draws1[1]
d2 = vals$draws2[1]
p1 <- ggplot(df, aes(x, y, color = dist)) +
geom_line(linewidth = 1.2) +
scale_color_manual(values = c("navy","steelblue1")) +
{
if (length(vals$draws1) > 0) {
list(
geom_segment(aes(
x = d1,
xend = d2,
y = 0, yend = 0
), color = "firebrick1", linewidth = 0.75, inherit.aes = FALSE),
geom_point(aes(x = d1, y = 0), color = "navy", size = 3, inherit.aes = FALSE),
geom_point(aes(x = d2, y = 0), color = "steelblue1", size = 3, inherit.aes = FALSE),
geom_segment(aes(x = d1, xend = d1, yend = df.x1$y[which.min(abs(df.x1$x - d1))], y = 0), color = "navy") ,
geom_segment(aes(x = d2, xend = d2, yend = df.x2$y[which.min(abs(df.x2$x - d2))], y = 0), color = "steelblue1")
)
}
} +
theme_minimal(base_size = 14) +
labs(x = "Value", y = "Density", color = "Distribution")
p1
n_points <- length(vals$diffs)
binwidth <- 0.2
# Parameters for theoretical difference distribution
mu_diff <- mu1 - mu2
sd_diff <- sqrt(sd1^2 + sd2^2 - 2 * input$rho * sd1 * sd2)
sd_diff0 <- sqrt(sd1^2 + sd2^2 )
# Maximum expected count occurs at the mode (center of normal)
expected_max <- n_points * dnorm(mu_diff, mean = mu_diff, sd = sd_diff) * binwidth
# Add a small margin
y_max <- ceiling(expected_max) + ceiling(sqrt(n_points))
if(y_max==Inf) {y_max = n_points + ceiling(n_points/50) }
# Histogram
p2 <-  ggplot() +
geom_histogram(aes(x = vals$diffs), binwidth = binwidth, fill = "firebrick1", color = "black") +
coord_cartesian(
xlim = c(mu_diff + -4*sd_diff0 - binwidth, mu_diff + 4*sd_diff0 + binwidth),
ylim = c(0, y_max)  # y-axis expands in steps
) +
theme_minimal(base_size = 14) +
labs(x = "x̄₁ - x̄₂", y = "Count", title =paste0("Correlation: ", cr))
p2
ggplot(data.frame(x1 = vals$draws1, x2 = vals$draws2)) +
geom_point(aes(x = x1, y = x2)) +
theme_bw() +
labs(x = "x̄1", y = "x̄2")
library(shiny)
?plotOutput
install.packages("extraDistr")
library(extraDistr)
?extraDistr::dlst
?dt
sqrt(2.15^2/735 + 2.15^2/735)
power.t.test(delta = abs(input$mu_true - input$mu0),
n = 735,
sd = 2.15,
sig.level = .05,
type = "one.sample",
alternative = sides)$power
power.t.test(delta = abs(0.2),
n = 735,
sd = 2.15,
sig.level = .05,
type = "one.sample",
alternative = sides)$power
power.t.test(delta = abs(0.2),
n = 735,
sd = 2.15,
sig.level = .05,
type = "one.sample",
alternative = "two.sided")$power
power.t.test(delta = abs(0.2),
n = 735,
sd = 2.15,
sig.level = .05,
type = "two.sample",
alternative = "two.sided")$power
power.t.test(delta = abs(0.25),
n = 735,
sd = 2.15,
sig.level = .05,
type = "two.sample",
alternative = "two.sided")$power
power.t.test(delta = abs(0.4),
n = 735,
sd = 2.15,
sig.level = .05,
type = "two.sample",
alternative = "two.sided")$power
power.t.test(delta = abs(0.3),
n = 735,
sd = 2.15,
sig.level = .05,
type = "two.sample",
alternative = "two.sided")$power
sd(sample)
input$n = 10000
input = list(n = 10000)
n
input$n
n1 = n
n2 = n
sample1 <- rnorm(n1, mean = input$mu_true - 1.75, sd = (4 * input$sigma - 3.5) / 4)  # First mode
n1
n2
n1 = nput$n
n1 = 10000
n2 = 10000
sample1 <- rnorm(n1, mean = input$mu_true - 1.75, sd = (4 * input$sigma - 3.5) / 4)  # First mode
sample2 <- rnorm(n2, mean = input$mu_true + 1.75, sd = (4 * input$sigma - 3.5) / 4)  # Second mode
sample <- c(sample1, sample2)
input
n
n = 10000
n1
n2
sample1 <- rnorm(n1, mean = input$mu_true - 1.75, sd = (4 * input$sigma - 3.5) / 4)  # First mode
sample2 <- rnorm(n2, mean = input$mu_true + 1.75, sd = (4 * input$sigma - 3.5) / 4)  # Second mode
sample <- c(sample1, sample2)
input
0.3 / 0.112
